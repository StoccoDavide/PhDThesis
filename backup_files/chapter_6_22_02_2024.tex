%!TEX root = ../main.tex

\chapter{Differential-Algebraic Equations Index Reduction and Numerical Solution}
\label{chap6:daes}

\subsubsection*{Copyright Notice}
Part of this chapter has been first published in
%
\begin{center}
  \begin{minipage}{0.9\textwidth}
    \fullcite{stocco2024symbolic}
  \end{minipage}
\end{center}
\begin{center}
  \begin{minipage}{0.9\textwidth}
    \fullcite{stocco2024matrix}
  \end{minipage}
\end{center}
%
by Springer and Elsevier, respectively. Reproduced with permission from Springer and Elsevier.

\begin{center}
  $\ast$~$\ast$~$\ast$
\end{center}

In this work, a framework for the automatic symbolic index reduction and numerical integration of generic differential-algebraic equation systems is presented. The proposed approach does not exploit any a priori knowledge of the specific differential-algebraic system of equation formulation. The index reduction is performed only with the aim of linear algebra techniques. Hierarchical representation of expressions is conveniently used to limit expression swell and ensure the numerical stability of the solution. The effectiveness of the algorithm is validated through symbolic and numerical experiments on a multi-body model.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Introduction}
\label{chap6:sec:introduction}

Index reduction of \ac{DAE} systems is a well-known problem in numerical analysis. It consists of recasting a \ac{DAE} system into an equivalent system with a lower index. The index is roughly defined as the number of times the algebraic equations are differentiated to obtain an equivalent system of \acp{ODE}. The index reduction process is a fundamental step in \acp{DAE} numerical integration. The main reason is that the numerical integration of a \ac{DAE} system with a high index requires the solution of non-linear systems of equations at each integration step, which can be computationally expensive and, in some cases, numerically unstable. Specific numerical techniques have been developed to address this problem~\cite{petzold1982differential,thomsen1999numerical}. However, these techniques are not always effective and, in some cases, they are not even applicable. For these reasons, index reduction is an essential prior step to the numerical integration process~\cite{lamour2013differential}. Due to its complicated nature, it is usually carried out by exploiting the structure of the \ac{DAE} system~\cite{zhou2005implicit,zhou2007symbolic} or through other techniques like generalized coordinate partitioning~\cite{wehage1982generalized}.

In this work, a methodology for the automatic index reduction of generic \ac{DAE} systems is presented. With the proposed methodology, we do not want to exploit any a priori knowledge of the specific \ac{DAE} system formulation. The reduction is performed only by using symbolic manipulation with linear algebra techniques. The manuscript is structured as follows. In Section~\ref{sec:algorithm} we present the index reduction algorithm and introduce the issues that the authors faced during the implementation of the algorithm. The next sections are dedicated to the presentation of the open-source software solutions developed by the authors to address the aforementioned issues. Specifically, in Section~\ref{sec:lem} we discuss the expression swell problem, while in Section~\ref{sec:last} the matrix factorization and the \LAST{} package are introduced. In Section~\ref{sec:indigo} we present the \Indigo{} toolbox. Finally, Section~\ref{sec:experiment} reports an experiment of index reduction and numerical integration of a mechanical system. Future developments and some conclusions are discussed in Sections~\ref{sec:future_work} and \ref{sec:conclusions}.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Index Reduction Algorithm}
\label{chap6:sec:algorithm}

In this section, we approach the problem of reducing the index of \ac{DAE} systems from a theoretical standpoint. To achieve a consistent and systematic reduction of the \ac{DAE} system index, we present a novel iterative algorithm. This algorithm comprises two main steps: the separation of the differential component from the algebraic component of the \acp{DAE}, and the differentiation of the algebraic part to obtain a transformed system that has a lower index.

\subsection{Differential and Algebraic Equations Separation}

The first step in the index reduction process involves separating the differential part from the algebraic part of the \ac{DAE} system. To achieve this, one can manually identify and separate the algebraic equations from the remaining system components. However, this approach is error-prone, inconvenient, and not easily scalable for large systems. It is possible to automatize the separation process by exploiting the \emph{cokernel} (or \emph{left null space}), which can be computed through matrix factorization techniques.

Given a generic system of \acp{DAE} of the form
%
\begin{equation}
    \label{chap6:eq:daes}
    \mE \, \vX^\prime = \mG \text{,}
\end{equation}
%
we define the cokernel $\mK$ and its orthogonal complement $\mN$ of $\mE$. The separation of the differential part from the algebraic part is performed as
%
\begin{equation}
    \label{chap6:eq:separated_daes}
    \left\{\begin{array}{l}
        \mEt \, \vX^\prime = \mGt \\[0.4em]
        \mA = \m{0}
    \end{array}\right. \text{,}
    %
    \qquad \text{where} \qquad
    %
    \begin{array}{l}
        \mEt = \mN \, \mE \text{,} \\[0.5mm]
        \mGt = \mN \, \mG \text{,} \\[0.5mm]
        \mA  = \mK \, \mG \text{.}
    \end{array}
\end{equation}
%
An equivalent \ac{DAE} system with explicitly separated algebraic equations $\mA$ is obtained.

\subsubsection{Kernel Computation}

The cokernel $\m{K}$ of a generic matrix $\m{A}$ can be computed by finding all the solutions of the linear system $\m{A}\m{x} = \m{0}$. It is common knowledge that several matrix factorization techniques can be applied to address this problem. One of the most used is the LU factorization. The full-pivoting LU  of a $m \times n$ matrix $\m{A}$ is the quadruple of matrices $\m{L}$, $\m{U}$, $\m{P}$ and $\m{Q}$ such that
%
\begin{itemize}
  \setlength{\itemsep}{0pt}
    \item $\m{P}\m{A}\m{Q} = \m{L}\m{U}$;
    \item $\m{L} \in \mathbb{R}^{m \times m}$ is a lower-triangular matrix with all diagonal entries equal to $1$;
    \item $\m{U} \in \mathbb{R}^{m \times n}$ is a upper-triangular matrix;
    \item $\m{P} \in \mathbb{R}^{m \times m}$ is a row permutation matrix (notice that $\m{P}^{-1} = \m{P}^\top$);
    \item $\m{Q} \in \mathbb{R}^{n \times n}$ is a column permutation matrix (notice that $\m{Q}^{-1} = \m{Q}^\top$).
\end{itemize}
%
Defining $\m{M} = \m{L}^{-1}\m{P}$, we have that
%
\begin{equation}
    \m{M}\m{A} = (\m{L}^{-1}\m{P})(\m{P}^\top\m{L}\m{U}\m{Q}^\top) = \m{U\m{Q}^\top} = \begin{bmatrix} \m{U}_1 \\[0.4em] \m{0} \end{bmatrix}\m{Q}^\top \text{.}
\end{equation}
%
where $\m{U}_1$ is a square upper-triangular matrix. By partitioning the identity matrix $\m{I}$ as
%
\begin{equation}
    \m{I} = \begin{bmatrix}
        \,\m{I}_1\, & \m{0} \\[0.4em]
        \m{0} & \,\m{I}_2\,
    \end{bmatrix} \text{,}
\end{equation}
%
the following relation holds
%
\begin{equation}
    \begin{bmatrix} \,\m{I}_1\, & \,\m{0}\, \end{bmatrix} \, \m{M}\m{A} = \m{U}_1 \m{Q}^\top
    %
    \text{,} \qquad
    %
    \begin{bmatrix} \,\m{0}\, & \,\m{I}_2\, \end{bmatrix} \, \m{M}\m{A} = \m{0} \text{.}
\end{equation}
%
Eventually, the matrices $\m{N}$ and $\m{K}$, which are used for the separation of the differential part from the algebraic part, have the following form
%
\begin{equation}
    \m{N} = \begin{bmatrix} \,\m{I}_1\, & \,\m{0}\, \end{bmatrix} \, \m{M}
    %
    \quad \text{and} \quad
    %
    \m{K} = \begin{bmatrix} \,\m{0}\, & \,\m{I}_2\, \end{bmatrix} \, \m{M},
    %
    \quad \text{where} \quad
    %
    \begin{array}{l}
        \m{K}\m{A} = \m{0} \text{,} \\[0.5mm]
        \m{N}\m{A} = \m{U}_1 \, \text{is full-rank,} \\[0.5mm]
        \begin{bmatrix} \m{N} \\ \m{K} \end{bmatrix} \text{is non-singular.}
    \end{array}
\end{equation}

\subsection{Differentiation of the Algebraic Equations}

After the separation of the differential part from the algebraic part of the \ac{DAE} system in Eq.~\eqref{chap6:eq:daes}, the equivalent system given in Eq.~\eqref{chap6:eq:separated_daes} is obtained. One can now proceed with the differentiation of the algebraic equations $\mA$. The new system of \acp{DAE} with reduced index is of the form
%
\begin{equation}
    \label{chap6:eq:reduced_daes}
    \left\{\begin{array}{l}
        \mEt \, \vX^\prime = \mGt \\[0.4em]
        \mAE \, \vX^\prime = \mAG
    \end{array}\right.,
\end{equation}
%
where $\mAE$ and $\mAG$ are derived from the differentiation of $\mA$, namely
%
\begin{equation}
    \dfrac{\mathrm{d}}{\mathrm{d}t} \mA = \mAE \, \vX^\prime - \mAG.
\end{equation}
%
The successive process of separating and subsequently differentiating the algebraic part of the system results is repeated until the vector $\mA$ is empty or, equivalently, until the matrix $\mE$ is non-singular. When this condition is met, the \ac{DAE} system is reduced to an \ac{ODE} system with \emph{invariants} $\mH$. In this paper, the invariants are considered to be all the algebraic equations $\mA$ obtained from the index reduction process stages. Eventually, the concept of invariants can be extended to include user-defined algebraic equations to preserve system valuable properties (\emph{e.g.}, energy).

\subsection{Known Issues}

Although the algorithm just presented is quite basic and easy to implement, it has a number of issues that are dictated more by the technology that is used rather than by the underlying theory.
%
\begin{itemize}
  \setlength{\itemsep}{0pt}
    \item During symbolic manipulation of the \ac{DAE} system, the complexity of expressions is expected to increase relentlessly. Expression simplification is not always possible due to the software capabilities or excessively large CPU time. How can we make our algorithm insensible to expression swell?
    \item The description of the algorithm we have given consists of linear algebra manipulation of matrices and vectors with symbolic entries. How can we guarantee that the symbolic matrix factorization is also numerically stable?
    \item As a consequence of the previous question, one can conclude that in the LU decomposition case, a good symbolic pivoting strategy is crucial for the numerical stability of the output~\cite{giesbrecht2014symbolic,zhou2007symbolic,zhou2005implicit}. In particular, the chosen pivots must be both algebraically and numerically non-zero. How can we ensure that a given complicated expression is stable with a reasonable degree of confidence?
\end{itemize}
%
These are some of the issues the authors are aware of when it comes to implementing the algorithm. In the next sections, we address each of these challenges by giving some practical advice and providing open-source software solutions.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Index Reduction and Numerical Integration Scheme}
\label{chap6:sec:indigo}

After this fairly long discussion on the actual implementation aspects of the index reduction algorithm, we can now present the \Indigo{} index reduction and integration toolbox~\cite{indigo}. This toolbox consists of two main components: a \Maple{} package to carry out symbolic index reduction of \ac{DAE} systems, and a \Matlab{} toolbox to perform numerical integration of the reduced-index system. \Indigo{} is designed to be used in conjunction with the \LEM{} package, to limit the expression swell, and the \LAST{} package, to conveniently factorize matrices. In the following paragraphs, we briefly discuss the usage of the \Indigo{} package.

\subsection{Index Reduction}

The index reduction algorithm implemented in the \Indigo{} \Maple{} package is the one presented in Section~\ref{sec:algorithm}. To reduce the index of a \ac{DAE} system in the \Maple{} environment we need to first create an \Indigo{} object instance.
%
\begin{verbatim}
> Indigo_obj := Object(Indigo);
> Indigo_obj:-InitLAST();
\end{verbatim}
%
Then, the system of \acp{DAE} \texttt{eqns} with coordinates \texttt{vars} is loaded.
%
\begin{verbatim}
> Indigo_obj:-LoadEquations('Generic', eqns, vars);
\end{verbatim}
%
The \texttt{Generic} symbol is used to specify the type of the system. Notice that in this example, we assume that the equations of the system are already available in the \Maple{} session. The automatic index reduction process can be performed by calling the \texttt{ReduceIndex} method, which iterates the separation and differentiation steps until an index-$0$ \ac{DAE} system is obtained.
%
\begin{verbatim}
> Indigo_obj:-ReduceIndex();
\end{verbatim}
%
Intermediate results of the process are stored internally in the \Indigo{} object and are available on demand. Once the index reduction process is completed, the user can generate the \texttt{SliderCrank} \Matlab{} class file to perform numerical integration of the reduced-index system.
%
\begin{verbatim}
> Indigo_obj:-GenerateMatlabCode(name, type, data=pars);
\end{verbatim}
%
A file \texttt{name.m} is generated in the current directory. As it is explained in the next section, The string parameter \texttt{type} can be either \texttt{Implicit}, \texttt{SemiExplicit} or \texttt{Explicit} depending on the desired numerical integration scheme. The optional parameter \texttt{data} introduces default internal object data.

\subsection{Numerical Integration Scheme}

The \Indigo{} \Matlab{} toolbox is an object-oriented library that allows the user to exploit the automatically generated code of the reduced-index system. It is capable of integrating systems of \acp{ODE} and \acp{DAE} using a variety of Runge-Kutta numerical integration schemes. In particular, the system of equations which is integrated is composed of the following elements.
%
\begin{itemize}
  \setlength{\itemsep}{0pt}
    \item A differential part, which can be expressed by one of the following classes:
    %
    \begin{equation}
        \begin{array}{ccl}
            \m{F}(\vX, \vX^\prime, \m{v}, t) = \m{0} & \hspace{0.5cm} &
            \text{\texttt{Implicit} system class,} \\[0.5mm]
            \m{A}(\vX, \m{v}, t) \, \vX^\prime = \m{b}(\vX, \m{v}, t) & \hspace{0.5cm} &
            \text{\texttt{SemiExplicit} system class,} \\[0.5mm]
            \vX^\prime = \m{f}(\vX, \m{v}, t) & \hspace{0.5cm} &
            \text{\texttt{Explicit} system class.}
        \end{array}
    \end{equation}
    %
    \item The invariants, composed of the hidden constraints obtained from the index reduction process $h_{i}(\vX, \m{v}, t)$, and optional user-defined invariants $h_{u}(\vX, \m{v}, t)$, namely
    %
    \begin{equation}
        \label{chap6:eq:inv_part}
        \m{h}(\vX, \m{v}, t) = \begin{bmatrix}
            h_{i}(\vX, \m{v}, t) \\[0.5mm]
            h_{u}(\vX, \m{v}, t) \\[0.5mm]
        \end{bmatrix} = \m{0} \text{.}
    \end{equation}
    %
    \item The veils, which are the set of the expression hierarchical representation variables used in \LEM{} to limit the expression swell
    %
    \begin{equation}
        \m{v}(\vX, t) = \begin{bmatrix}
            v_{1}(\vX, t) \\[0.5mm]
            v_{2}(v_{1}, \vX, t) \\
            \vdots \\
            v_{n}(v_{1}, \dots, v_{n-1}, \vX, t)
        \end{bmatrix} \text{.}
    \end{equation}
\end{itemize}

To respect the invariants during the integration the \emph{standard projection} method is applied \cite{hairer2000symmetric}. This method consists of projecting the solution $\vX$ of the numerically integrated reduced-index system onto the invariants manifold $\m{h}(\vX, \m{v}, t) = \m{0}$, which is equivalent to the following constrained minimization
%
\begin{equation}
  \underset{\widetilde{\vX}}{\textrm{minimize}} \quad \dfrac{1}{2}\left(\vX - \widetilde{\vX}\right)^2
    \quad \textrm{subject to} \quad
    \m{h}(\vX, \m{v}, t) = \m{0}.
\end{equation}

To integrate the system generated through the \Matlab{} package or a custom system \texttt{sys}, the user must first instantiate a \Indigo{} Runge-Kutta solver.
%
\begin{verbatim}
>>> solver = IndigoSolver('solver_name');
>>> solver.set_system(sys);
\end{verbatim}
%
Once the solver is instantiated, it is only necessary to specify the initial conditions and the integration time vector.
%
\begin{verbatim}
>>> [x, x_dot, t, v, h] = solver.solve(t_ini:d_t:t_end, ics);
\end{verbatim}
%
The solver returns the solution of the system in the form of multiple outputs: \texttt{x} contains the integrated solution, \texttt{x\_dot} the states' time derivative, \texttt{t} the time vector, \texttt{v} the veiling variables, and finally \texttt{h} the values of the invariants over the specified time mesh \texttt{t\_ini:d\_t:t\_end}.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Slider Crank Mechanism}
\label{chap6:sec:experiment}

In this section, an experiment using the symbolic-numerical \Indigo{} library is presented. The experiment consists of a simple slider crank mechanism illustrated in \figurename~\ref{chap6:fig:slider_crank}, which is similar to that in~\cite{zhou2007symbolic}. The formulations that can be used to describe this mechanism are mainly two: the recursive and the global ones. These are equivalent, but the coordinates used to describe the system are different. This aspect is very important in the index reduction process as it can significantly affect the choice of the LU pivots. In the following paragraphs, we report the two \ac{DAE} systems arising from these two formulations, which are both written as a multi-body system in the general form, \emph{i.e.},
%
\begin{equation}
    \label{chap6:eq:multi_body_system}
    \left\{\begin{array}{l}
        \m{M}(\mq, \mqd, t) \, \mqdd + \m{\Phi}_{\mq}(\mq, t)^\top \, \ml = \m{f}(\mq, \mqd, t) \\[2mm]
        \m{\Phi}(\mq, t) = \m{0}
    \end{array}\right. \text{,}
\end{equation}
%
where $\m{\Phi}_{\mq}(\mq, t)$ is the Jacobian matrix of the constraint vector $\m{\Phi}(\mq, t)$ with respect to the coordinates $\mq$.

\begin{figure}[htp!]
    \centering
    \begin{minipage}{0.5\textwidth}
        %\includegraphics[width=1.0\textwidth]{./ipe/SliderCrank.pdf}
    \end{minipage}
    \hspace{2pt}
    \begin{minipage}{0.35\textwidth}
        \small\emph{Legend:}\\
        $m_1$: crank mass, \\
        $J_1$: crank moment of inertia, \\
        $\ell_i$: crank length, \\
        $m_2$: rod mass, \\
        $J_2$: rod moment of inertia, \\
        $\ell_2$: rod length, \\
        $m_3$: slider mass. \\
    \end{minipage}
    \caption{The slider crank mechanism~\cite{zhou2007symbolic}. The crank is linked to the ground by a revolute joint. The connecting rod is attached to the crank and to the slider by revolute joints. The slider is linked to the ground by a prismatic joint.}
    \label{chap6:chap6:fig:slider_crank}
\end{figure}

\subsubsection{Recursive Formulation}

Similarly to~\cite{zhou2007symbolic}, the system is formulated in terms of the angle between the crank and the connecting rod, and the angle between the connecting rod and the slider surface, that is $\mq = [\theta_1, \theta_2]^\top$. The components are
%
\begin{subequations}
    \small
    \begin{equation*}
        \m{M}(\mq, \mqd, t) = \begin{bmatrix}
            \ell_1^2\left(\frac{1}{4}m_1+m_2+m_3\right) + J_1 &
            -\ell_1\ell_2\cos(\theta_1+\theta_2)\left(\frac{1}{2}m_2+m_3\right) \\[1mm]
            -\ell_1\ell_2\cos(\theta_1+\theta_2)\left(\frac{1}{2}m_2+m_3\right) &
            \ell_2^2\left(\frac{1}{4}m_2+m_3\right) + J_2
          \end{bmatrix} \text{,}
    \end{equation*}
    \begin{equation*}
        \m{f}(\mq, \mqd, t) = \begin{bmatrix}
            -\ell_1 g \left(\frac{1}{2}m_1+m_2+m_3\right) \cos(\theta_1) - \ell_1 \ell_2 \theta_2^{\prime 2} \sin(\theta_1+\theta_2) \left(\frac{1}{2}m_2+m_3\right) \\[1mm]
            \ell_2 g \left(\frac{1}{2}m_2+m_3\right) \cos(\theta_2) - \ell_1 \ell_2 \theta_1^{\prime 2} \sin(\theta_1+\theta_2) \left(\frac{1}{2}m_2+m_3\right)
        \end{bmatrix} \text{,}
    \end{equation*}
    \begin{equation*}
        \m{\Phi}(\mq, t) = \begin{bmatrix}
            \ell_1 \sin(\theta_1) - \ell_2 \sin(\theta_2)
        \end{bmatrix} \text{.}
    \end{equation*}
\end{subequations}

\subsubsection{Global Formulation}

The system is formulated in a global fashion when each node is described by its Cartesian coordinates and its orientation angle, namely $\mq = [x_1, y_1, \theta_1, x_2, y_2, \theta_2]^\top$. The system is described by the following equations
%
\begin{subequations}
    \small
    \begin{equation*}
        \m{M}(\mq, \mqd, t) = \begin{bmatrix}
          m_1    & 0      & a_{13} & 0      & 0      & 0 \\
          0      & m_{1}  & a_{23} & 0      & 0      & 0 \\
          a_{31} & a_{23} & a_{33} & 0      & 0      & 0 \\
          0      & 0      & 0      & a_{44} & 0      & a_{46} \\
          0      & 0      & 0      & 0      & a_{55} & a_{56}\\
          0      & 0      & 0      & a_{64} & a_{65} & a_{66}
      \end{bmatrix}  \text{,}
      %
      \quad \text{where} \quad
      %
      \begin{array}{l}
        a_{13} = a_{31} = -\frac{1}{2} \ell_1 m_1 \sin(\theta_1) \text{,} \\[1mm]
        a_{23} = a_{32} =  \frac{1}{2} \ell_1 m_1 \cos(\theta_1) \text{,} \\[1mm]
        a_{33} = \frac{1}{4} \ell_1^2 m_1 +J_1 \text{,} \\[1mm]
        a_{44} = a_{55} = m_2 + m_3 \text{,} \\[1mm]
        a_{46} = a_{64} = -\frac{1}{2} \ell_2 (m_2 + 2 m_3) \sin(\theta_2) \text{,} \\[1mm]
        a_{56} = a_{65} = -\frac{1}{2} \ell_2 (m_2 + 2 m_3) \cos(\theta_2) \text{,} \\[1mm]
        a_{66} = \frac{1}{4} \ell_2^2 (m_{2} + 4 m_{3}) + J_2 \text{,}
      \end{array}
    \end{equation*}
    %
    \begin{equation*}
        \m{f}(\mq, \mqd, t) = \begin{bmatrix}
            -\frac{1}{2} \ell_1 m_1 \theta_1^{\prime 2} \cos(\theta_1) \\[1mm]
            -\frac{1}{2} \ell_1 m_1 \theta_1^{\prime 2} \sin(\theta_1) + m_1 g \\[1mm]
            \frac{1}{2} \ell_1 g   \theta_1^{\prime 2} \cos(\theta_1) \\[1mm]
            -\frac{1}{2} \ell_2 (m_2 + 2 m_3) \theta_2^{\prime 2} \cos(\theta_2) \\[1mm]
            -\frac{1}{2} \ell_2 (m_2 + 2 m_3) \theta_2^{\prime 2} \sin(\theta_2) + (m_2 + m_3) g \\[1mm]
            -\frac{1}{2} \ell_2 (m_2 + 2 m_3) g \theta_2^{\prime 2} \cos(\theta_2)
        \end{bmatrix}  \text{,}
        %
        ~
        %
        \m{\Phi}(\mq, t) = \begin{bmatrix}
            -x_1 \\
            -y_1 \\
            \ell_2 \sin(\theta_2) - y_2 \\
            x_2 - x_1 - \ell_1 \cos(\theta_1)  \\
            y_2 - y_1 - \ell_1 \sin(\theta_1)
        \end{bmatrix}  \text{.}
  \end{equation*}
\end{subequations}

\subsection{Experiment Results and Discussion}

Through the methodology presented in the previous Sections, the system in both formulations is reduced to an index-$0$ \ac{DAE} system through the \Indigo{} \Maple{} package. As we have mentioned before, the choice of the coordinates strongly influences the index reduction process as the choice of the LU decomposition pivots is based on the complexity of the expressions. While in the recursive formulation the equations are fewer but more complicated (trigonometric functions), in the global formulation the equations are more numerous but simpler (polynomials). The results in terms of overall expressions complexity of the index reduction process are reported in Table~\ref{chap6:tab:index_reduction}. As can be seen, the global formulation leads to a comparatively simpler expression even if the number of equations is higher.

\begin{table}[ht!]
    \centering
    \caption{Overall expressions complexity obtained during the index reduction process for the two formulations of the slider crank mechanism. \emph{Legend}: f: functions, a: additions, m: multiplications, d: divisions.}
    \label{chap6:chap6:tab:index_reduction}
    %
    \begin{tabular}{c@{\hskip 5mm}c@{\hskip 5mm}c}
        \toprule
        \textbf{Formulation}  & \textbf{Recursive} & \textbf{Global} \\
        \midrule
        Differential part               & 249f + 475a  + 1189m + 17d & 317f + 232a + 603m + 23d \\
        1\textsuperscript{st} invariant & 4f   + 1a    + 2m          & 13f  + 10a  + 18m \\
        2\textsuperscript{nd} invariant & 6f   + 1a    + 4m          & 16f  + 7a   + 6m \\
        3\textsuperscript{rd} invariant & 49f  + 85a   + 226m + 2d   & 92f  + 91a  + 244m + 17d \\
        \midrule
        Total                           & 308f + 562a + 1421m + 19d  & 438f + 340a + 871m + 40d \\
        \bottomrule
    \end{tabular}
\end{table}

The reduced-index system is integrated using the \Indigo{} \Matlab{} toolbox. The numerical integration is performed using the \texttt{Implicit} system class with the classic 4th-order Runge-Kutta solver. The results with and without projection on the invariant manifolds are reported in \figurename~\ref{chap6:fig:numerical_integration}. As expected, the two formulations lead to similar results. Notice that the \emph{standard projection} leads to a small linear drift of the total energy of the system. Indeed, this projection algorithm does not mitigate the geometric properties destruction of the differential equations numerical solution discretization, making it less suitable for long-time integration~\cite{hairer2000symmetric}.

\begin{figure}[ht!]
    \centering
    %\input{./tikz/theta.tex}
    \hfill
    %\input{./tikz/theta_proj.tex}
    \vspace*{-0.0pt}
    \hspace*{1.5pt} \\
    %\input{./tikz/energy.tex}
    \hfill
    %\input{./tikz/energy_proj.tex}
    \caption{Results of the numerical integration of the slider crank mechanism using the \texttt{Implicit} system class with classic 4th-order Runge-Kutta solver. The first column shows the results with no projection on the manifolds, while the second column shows the results with projection. \emph{Legend}: {\color{mycolor1}$\blacksquare$}: recursive formulation, {\color{mycolor2}$\blacksquare$}: global formulation.}
    \label{chap6:chap6:fig:numerical_integration}
\end{figure}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Future Work}
\label{chap6:sec:future_work}

The presented framework is still in a prototype form. Several methodological and implementation aspects are of interest for future work improvement. In particular, the symbolic factorization is based on the full-pivoting LU decomposition. Choosing the right pivot strategy is crucial for the final numerical stability of the reduced-index system. In the current implementation, the pivots are chosen based on the minimum degree technique to reduce fill-in and on the actual complexity of the expressions. However, this metric may be limited to ensure numerical stability and further investigations are needed to find more convenient symbolic manipulation strategies. \emph{Pantelides}~\cite{pantelides1988consistent}, \emph{Structural Matrix}~\cite{unger1995structural,unger1995structural}, or \emph{Dummy Derivatives}~\cite{mattsson1993index} may be explored to be used in conjunction with the here presented framework. The numerical projection scheme can also be improved. In particular, the \emph{symmetric projection} method would eliminate the linear drift of the system total energy~\cite{hairer2000symmetric}. Finally, the numerical integration toolbox is written in \Matlab{} language and it is not optimized for large-scale systems. A C++ version of the integrator would significantly boost the software's performance.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Conclusions}
\label{chap6:sec:conclusions}

In this paper a methodology for the automatic index reduction of \ac{DAE} systems is presented. The index reduction algorithm is based on the separation of the system into differential and algebraic parts with the help of linear algebra. An open-source implementation of the algorithm has been presented and discussed in its main aspects and components, \emph{i.e.}, \LEM{}, \LAST{}, and \Indigo{}. The \Indigo{} toolbox is made up of two main components: a \Maple{} package to perform index reduction of \ac{DAE} systems and automatic generation of \Matlab{} code, and a \Matlab{} toolbox to perform numerical integration of the reduced-index system. This toolbox is designed to be used in conjunction with the \LEM{} package, which is used to hierarchically represent large expressions, and with the \LAST{} package, which performs convenient expression-swell-insensible matrix factorization. A symbolic-numerical experiment, which involves a multi-body slider crank mechanism, shows the capabilities of the aforementioned toolboxes. The results show that the presented software is capable of reducing the index of the \ac{DAE} system and the reduced-index system retains good numerical stability in the integration process.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
